<html>
	<head>
		<style>
		body { margin: 0; }
		canvas { border: solid black; }
		</style>
	</head>

	<body>
		<canvas id="mycanvas"></canvas>

		<script id="vertexShader" type="notjs">
			precision mediump float;
			attribute vec2 a_position;
			attribute vec4 a_vert_color;
			varying vec4 v_frag_color;

			void main() {
			v_frag_color = a_vert_color;
			gl_Position = vec4(a_position,0.0,1.0);
			}
		</script>

		<script id="fragmentShader" type="notjs">
			precision mediump float;
			varying vec4 v_frag_color;

			void main() {
			gl_FragColor = v_frag_color;
			}
		</script>

		<script>
			// Create new html5 canvas and wegbl context
			function createCanvas() {
				canvas = document.getElementById("mycanvas");

				gl = canvas.getContext("webgl");

				// Make the canvas a square that fits the window
				marginFraction = 30;
				borderThickness = 1;

				canvas.style.borderWidth = borderThickness;

				if (window.innerHeight > window.innerWidth) {
					// Portrait orientation
					margin = window.innerWidth/marginFraction;
					canvas.style.margin = margin.toString();

					canvas.width = window.innerWidth - 2*margin - 2*borderThickness;
					canvas.height = window.innerWidth - 2*margin - 2*borderThickness;
				}
				else {
					// Landscape orientation
					margin = window.innerWidth/marginFraction;
					canvas.style.margin = margin.toString();

					canvas.width = window.innerHeight - 2*margin - 2*borderThickness;
					canvas.height = window.innerHeight - 2*margin - 2*borderThickness;
				}

				// Size the viewport according to the canvas size
				gl.viewport(0,0,canvas.width,canvas.height);
			}

			function canvasYToClipspace(y) {
				return (canvas.height - y + margin + borderThickness)/canvas.height*2 - 1;
			}

			function canvasXToClipspace(x) {
				return (x - margin - borderThickness)/canvas.height*2 - 1;
			}

			function mouseDown(event) {
				mouseDownX = event.clientX;
				mouseDownY = event.clientY;
				mouseDown = true;
			}

			function mouseUp(event) {
				mouseDown = false;
				vertices = vertices.concat([-1.0, -1.0, 50/255, 255/255, 255/255, 255/255]);
				vertices = vertices.concat([1.0, -1.0, 50/255, 255/255, 255/255, 255/255]);
				vertices = vertices.concat([canvasXToClipspace(event.clientX), canvasYToClipspace(event.clientY), 255/255, 255/255, 255/255, 255/255]);
			}

			function mouseMove(event) {
				if (mouseDown) {
					mouseMoveX = event.clientX;
					mouseMoveY = event.clientY;
					mouseChangeX = mouseMoveX - mouseDownX;
					mouseChangeY = mouseMoveY - mouseDownY;
				}
			}

			// Create a new shader of the specified type
			function createShader(type, source) {
				var shader = gl.createShader(type);

				gl.shaderSource(shader, source);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.error("Shader failed to compile", gl.getShaderInfoLog(shader));
					return false;
				}

				return shader;
			}

			// Create a program using a vertex and fragment shader
			function createProgram(vertexShader, fragmentShader) {
				var program = gl.createProgram();

				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);

				gl.linkProgram(program);

				return program;
			}

			// Prepare the attributes in the program to be interfaced by the rest of the program
			function prepareAttributes() {
				positionElements = 2; // 2 position elements per vertice (x, y)
				colorElements = 4; // 4 color elements per vertice (red, green, blue, alpha)
				totalElements = positionElements + colorElements; // The total number of elements per vertice (in this case 2 + 4)

				positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.vertexAttribPointer(positionAttributeLocation, positionElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, 0);

				colorAttributeLocation = gl.getAttribLocation(program, "a_vert_color");
				gl.vertexAttribPointer(colorAttributeLocation, colorElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, positionElements * Float32Array.BYTES_PER_ELEMENT);

				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.enableVertexAttribArray(colorAttributeLocation);
			}

			// Keeps drawing triangles until we run out of vertices
			function drawTriangles(vertices) {
				if (vertices.length >= totalElements) {
					gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
					gl.drawArrays(gl.TRIANGLES, 0, vertices.length/totalElements);
				}
			}

			// Declares all the vertices that will be drawn
			function declareVertices() {
				vertices = [];

				vertices = vertices.concat([ 0.0, -0.5, 0.0, 1.0, 0.4, 1.0]);
				vertices = vertices.concat([ 0.5,  0.5, 0.5, 0.0, 0.8, 1.0]);
				vertices = vertices.concat([-0.1,  0.8, 0.0, 0.0, 0.9, 1.0]);

				vertices = vertices.concat([-0.8, -0.1, 0.9, 0.4, 0.1, 1.0]);
				vertices = vertices.concat([ 0.2,  0.3, 0.8, 1.0, 0.2, 1.0]);
				vertices = vertices.concat([-0.5,  0.9, 0.9, 0.3, 0.1, 1.0]);

				return vertices;
			}

			// Render loop called every frame update
			function render() {
				gl.useProgram(program);

				// Clears the screen and temporary buffers
				gl.clearColor(42/255, 62/255, 96/255, 255/255);
				gl.clear(gl.COLOR_BUFFER_BIT);

				// Draws the vertices declared in main
				drawTriangles(vertices);

				// Render the next frame
				requestAnimationFrame(render);
			}

			// Main
			function main() {
				createCanvas();

				mouseDown = false;
				canvas.onmousedown = mouseDown;
				canvas.onmouseup = mouseUp;
				canvas.onmousemove = mouseMove;

				vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertexShader").text);
				fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragmentShader").text);

				program = createProgram(vertexShader, fragmentShader);

				vertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);

				prepareAttributes();

				//vertices = declareVertices();
				vertices = [];

				// Begins the render loop
				requestAnimationFrame(render);
			}

			main();
		</script>
	</body>
</html>
