<html>
	<head>
		<style>
		body { margin: 0; }
		canvas { border: solid black; }
		</style>
	</head>
	
	<body>
		<canvas id="mycanvas"></canvas>
		
		<script id="vertexShader" type="notjs">
			precision mediump float;
			attribute vec2 a_position;
			attribute vec4 a_vert_color;
			varying vec4 v_frag_color;
			
			void main() {
			v_frag_color = a_vert_color;
			gl_Position = vec4(a_position,0.0,1.0);
			}
		</script>
		
		<script id="fragmentShader" type="notjs">
			precision mediump float;
			varying vec4 v_frag_color;
			
			void main() {
			gl_FragColor = v_frag_color;
			}
		</script>
		
		<script>
			// Create new html5 canvas and wegbl context
			function createCanvas() {
				canvas = document.getElementById("mycanvas");
				
				gl = canvas.getContext("webgl");
				
				// Make the canvas a square that fits the window
				marginFraction = 30;
				borderThickness = 1;
				
				canvas.style.borderWidth = borderThickness;
				
				if (window.innerHeight > window.innerWidth) {
					// Portrait orientation
					margin = window.innerWidth/marginFraction;
					canvas.style.margin = margin.toString();
					
					canvas.width = window.innerWidth - 2*margin - 2*borderThickness;
					canvas.height = window.innerWidth - 2*margin - 2*borderThickness;
				}
				else {
					// Landscape orientation
					margin = window.innerWidth/marginFraction;
					canvas.style.margin = margin.toString();
					
					canvas.width = window.innerHeight - 2*margin - 2*borderThickness;
					canvas.height = window.innerHeight - 2*margin - 2*borderThickness;
				}
				
				// Size the viewport according to the canvas size
				gl.viewport(0,0,canvas.width,canvas.height);
			}
			
			function canvasYToClipspace(y) {
				return (canvas.height - y + margin + borderThickness)/canvas.height*2 - 1;
			}
			
			function canvasXToClipspace(x) {
				return (x - margin - borderThickness)/canvas.height*2 - 1;
			}
			
			function mouseDown(event) {
				mouseDownX = event.clientX;
				mouseDownY = event.clientY;
				mouseDown = true;
			}
			
			function mouseUp(event) {
				mouseDown = false;
				// A blue faded triangle from the bottom of the screen
				vertices = vertices.concat([-1.0, -1.0, 50/255, 255/255, 255/255, 255/255]);
				vertices = vertices.concat([1.0, -1.0, 50/255, 255/255, 255/255, 255/255]);
				vertices = vertices.concat([canvasXToClipspace(event.clientX), canvasYToClipspace(event.clientY), 255/255, 255/255, 255/255, 255/255]);
			}
			
			// Create a new shader of the specified type
			function createShader(type, source) {
				var shader = gl.createShader(type);
				
				gl.shaderSource(shader, source);
				gl.compileShader(shader);
				
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.error("Shader failed to compile", gl.getShaderInfoLog(shader));
					return false;
				}
				
				return shader;
			}
			
			// Create a program using a vertex and fragment shader
			function createProgram(vertexShader, fragmentShader) {
				var program = gl.createProgram();
				
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				
				gl.linkProgram(program);
				
				return program;
			}
			
			// Prepare the attributes in the program to be interfaced by the rest of the program
			function prepareAttributes() {
				positionElements = 2; // 2 position elements per vertice (x, y)
				colorElements = 4; // 4 color elements per vertice (red, green, blue, alpha)
				totalElements = positionElements + colorElements; // The total number of elements per vertice (in this case 2 + 4)
				
				positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.vertexAttribPointer(positionAttributeLocation, positionElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, 0);
				
				colorAttributeLocation = gl.getAttribLocation(program, "a_vert_color");
				gl.vertexAttribPointer(colorAttributeLocation, colorElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, positionElements * Float32Array.BYTES_PER_ELEMENT);
				
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.enableVertexAttribArray(colorAttributeLocation);
			}
			
			// Keeps drawing triangles until we run out of vertices
			function drawTriangles(vertices) {
				if (vertices.length >= totalElements) {
					gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
					gl.drawArrays(gl.TRIANGLES, 0, vertices.length/totalElements);
				}
			}
			
			// Declares all the vertices that will be drawn
			function declareVertices() {
				vertices = [];

				var axisThickness = 0.01;
				var axisWidth = 0.9;
				var axisColor = [0/255, 0/255, 0/255, 255/255];
				
				// X axis made of two triangles
				vertices = vertices.concat([-axisWidth,  axisThickness]).concat(axisColor);
				vertices = vertices.concat([-axisWidth, -axisThickness]).concat(axisColor);
				vertices = vertices.concat([ axisWidth,  axisThickness]).concat(axisColor);
				
				vertices = vertices.concat([ axisWidth,  axisThickness]).concat(axisColor);
				vertices = vertices.concat([ axisWidth, -axisThickness]).concat(axisColor);
				vertices = vertices.concat([-axisWidth, -axisThickness]).concat(axisColor);
				
				// Y axis made of two triangles
				vertices = vertices.concat([ axisThickness, -axisWidth]).concat(axisColor);
				vertices = vertices.concat([-axisThickness, -axisWidth]).concat(axisColor);
				vertices = vertices.concat([ axisThickness,  axisWidth]).concat(axisColor);
				
				vertices = vertices.concat([ axisThickness,  axisWidth]).concat(axisColor);
				vertices = vertices.concat([-axisThickness,  axisWidth]).concat(axisColor);
				vertices = vertices.concat([-axisThickness, -axisWidth]).concat(axisColor);
				
				return vertices;
			}
			
			// Render loop called every frame update
			function render() {
				gl.useProgram(program);
				
				// Clears the screen and temporary buffers
				gl.clearColor(255/255, 255/255, 255/255, 255/255);
				gl.clear(gl.COLOR_BUFFER_BIT);
				
				// Draws the vertices declared in main
				drawTriangles(vertices);
				
				// Render the next frame
				requestAnimationFrame(render);
			}
			
			// Main
			function main() {
				createCanvas();
				
				mouseDown = false;
				canvas.onmousedown = mouseDown;
				canvas.onmouseup = mouseUp;
				
				vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertexShader").text);
				fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragmentShader").text);
				
				program = createProgram(vertexShader, fragmentShader);
				
				vertexBufferObject = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
				
				prepareAttributes();
				
				vertices = declareVertices();
				
				// Begins the render loop
				requestAnimationFrame(render);
			}
			
			main();
		</script>
	</body>
</html>
