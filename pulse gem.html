<html>
	<head>
		<style>
			body { margin: 0; }
			canvas { border: solid black; }
		</style>
	</head>

	<body>
		<canvas id="mycanvas"></canvas>
		
		<script id="vertexShader" type="notjs">
			precision mediump float;
			attribute vec2 a_position;
			attribute vec4 a_vert_color;
			varying vec4 v_frag_color;
			
			void main() {
				v_frag_color = a_vert_color;
				gl_Position = vec4(a_position,0.0,1.0);
			}
		</script>

		<script id="fragmentShader" type="notjs">
			precision mediump float;
			varying vec4 v_frag_color;
			
			void main() {
				gl_FragColor = v_frag_color;
			}
		</script>

		<script>
		    // Create new html5 canvas and wegbl context
            var createCanvas = function () {
                canvas = document.getElementById("mycanvas");

			    gl = canvas.getContext("webgl");
			
			    // Make the canvas a square that fits the window
			    var marginFraction = 30;
			    var borderThickness = 0;
			
			    canvas.style.borderWidth = borderThickness;

			    if (window.innerHeight > window.innerWidth) {
                    // Portrait orientation
				    var margin = window.innerWidth/marginFraction;
				    canvas.style.margin = margin.toString();
					
				    canvas.width = window.innerWidth - 2*margin - 2*borderThickness;        
				    canvas.height = window.innerWidth - 2*margin - 2*borderThickness;
			    }
				else {
                    // Landscape orientation
				    var margin = window.innerWidth/marginFraction;
				    canvas.style.margin = margin.toString();
					
				    canvas.width = window.innerHeight - 2*margin - 2*borderThickness;
				    canvas.height = window.innerHeight - 2*margin - 2*borderThickness;
			    }
			
			    // Size the viewport according to the canvas size
			    gl.viewport(0,0,canvas.width,canvas.height);
            }

            // Create a new shader of the specified type
            var createShader = function (type, source) {
                var shader = gl.createShader(type);

                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error("Shader failed to compile", gl.getShaderInfoLog(shader));
                    return false;
                }

                return shader;
            }

            // Create a program using a vertex and fragment shader
            var createProgram = function (vertexShader, fragmentShader) {
                var program = gl.createProgram();

                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);

                gl.linkProgram(program);
                
                return program;
            }

            // Prepare the attributes in the program to be interfaced by the rest of the program
            var prepareAttributes = function () {
                positionElements = 2; // 2 position elements per vertice (x, y)
                colorElements = 4; // 4 color elements per vertice (red, green, blue, alpha)
                totalElements = positionElements + colorElements; // The total number of elements per vertice (in this case 2 + 4)

                positionAttributeLocation = gl.getAttribLocation(program, "a_position");
                gl.vertexAttribPointer(positionAttributeLocation, positionElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, 0);

                colorAttributeLocation = gl.getAttribLocation(program, "a_vert_color");
                gl.vertexAttribPointer(colorAttributeLocation, colorElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, positionElements * Float32Array.BYTES_PER_ELEMENT);
                
                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.enableVertexAttribArray(colorAttributeLocation);
            }

            // Keeps drawing triangles until we run out of vertices 
            var drawTriangles = function (vertices) {
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, vertices.length/totalElements);
            }

            // Render loop called every frame update
            var render = function () {
                // Causes the red value to oscillate
                if (redIncreasing) {
                    if (red < 1.0) {
                        red += 0.01;
                    }
                    else {
                        redIncreasing = false;
                    }
                }
                else {
                    if (red > 0.0) {
                        red -= 0.01;
                    }
                    else {
                        redIncreasing = true;
                    }
                }

                // Begin just after the last position element (in other words the first color element)
                // Cycles through every red element in all the vertices and sets it to the global red value
                var i = positionElements;
                while (i < vertices.length) {
                    vertices[i] = red;
                    i += totalElements;
                }

                gl.useProgram(program);

                // Clears the screen and temporary buffers
                gl.clearColor(1.0, 1.0, 1.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Draws the vertices declared in main
                drawTriangles(vertices);

                // Render the next frame
                requestAnimationFrame(render);
            }

            // Main
            var main = function () {
                createCanvas();

                vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertexShader").text);
                fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragmentShader").text);

                program = createProgram(vertexShader, fragmentShader);

                vertexBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);

                prepareAttributes();

                vertices = [];
                vertices = vertices.concat([0.0, -0.5, 0.0, 1.0, 0.4, 1.0]); // bottom
                vertices = vertices.concat([0.5, 0.5, 0.0, 0.0, 1.0, 1.0]); // right
                vertices = vertices.concat([-0.2, 0.9, 0.0, 0.0, 0.0, 1.0]); // left

                red = 0.0;
                redIncreasing = false;

                // Begins the render loop
                requestAnimationFrame(render);
            }

            main();
		</script>
	</body>
</html>